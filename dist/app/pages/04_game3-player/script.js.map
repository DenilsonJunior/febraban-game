{"version":3,"sources":["script.js"],"names":["measures","canvasW","canvasH","timeGame","workAll","let","pointMulti","definedWords","document","gameWordSearch","window","countWord","word","WordSearch","activeTime","countdownTimer","$","trigger","gameCurrent","wordsBase","setTimeout","text","game","_this","this","puzzleWidth","puzzleHeight","each","tileHeight","index","value","words","push","removerAcentos","toLowerCase","drawLineAlpha","preload","puzzle","refresh","wordList","backgroundColor","tileWidth","drawLineColor","solution","drawLineThickness","highlightTintContainer","highlightTintIndice","highlightTint","column","drawLine","startWord","isSelecting","onInputUp","firstLetter","onInputOver","endLetter","foundWords","prototype","forEach","load","tile","orientation","entry","length","letter","nameIMG","spritesheet","x","scaleRatio","devicePixelRatio","scale","scaleMode","Phaser","ScaleManager","SHOW_ALL","x_InitSolution","x_SecondCol","y","create","stage","wordfind","newPuzzle","width","height","solve","found","listContainer","grid","add","group","li","row","classList","addEventListener","data","events","onInputDown","startLetterSelect","console","stopLetterSelect","overLetter","onInputOut","outLetter","updateDrawLine","pointer","clear","lineStyle","querySelector","indice","createElement","tinta","letters","error","input","selection","tw","gameWon","worldScale","_containerTela","moveTo","worldPosition","th","checkLetterAlignment","getLetterAt","getChildAt","bottom","first","result","selectedWord","concat","left","Math","clearLine","highlightCorrectWord","element","right","tint","replace","getSelectedLetters","setAll","starter","sprite","frame","á","completeWord","startRow","startColumn","endRow","endColumn","Ó","ü","abs","top","state","last","min","max","inverse","Utils","reverseString","checkSelectedLetters","s","map","â","Â","à","À","Á","ê","Ê","è","È","î","Î","ì","Ì","í","Í","õ","Õ","ô","Ô","ò","Ü","û","Û","ú","Ú","ù","Ù","a","Game","CANVAS","ready"],"mappings":"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","file":"script.js","sourcesContent":["const measures = {\r\n  canvasW: 920,\r\n  canvasH: 910,\r\n};\r\n\r\nconst gameCurrent = 3;\r\nconst timeGame = 60 * 1; ///60\r\nlet workAll = 0;\r\nconst pointMulti = 10;\r\nconst definedWords = [\r\n  \"Compliance\",\r\n  \"Crédito\",\r\n  \"ESG\",\r\n  \"LGPD\",\r\n  \"SAC\",\r\n  \"PLDFT\",\r\n  \"Libras\",\r\n  \"Sustentabilidade\",\r\n  \"Preparatório\",\r\n  \"Correspondentes\",\r\n];\r\n\r\n$(document).ready(function () {\r\n  gameWordSearch();\r\n});\r\n\r\nfunction countWord(word) {\r\n  workAll += word;\r\n}\r\n\r\nfunction activeTime() {\r\n  window.countdownTimer(timeGame, () => {\r\n    $(\"body\").trigger(\"game\", [gameCurrent, workAll * pointMulti]);\r\n  });\r\n}\r\n\r\nfunction completeWord() {\r\n  setTimeout(function () {\r\n    $(\"body\").trigger(\"game\", [gameCurrent, workAll * pointMulti]);\r\n  }, 1000 * 1);\r\n}\r\n\r\nfunction gameWordSearch() {\r\n  $(\".info .value\").text(\"01:00\");\r\n  var WordSearch = {};\r\n\r\n  WordSearch.Game = function (game) {\r\n    //  This is your word list. Add or remove any words you like in here.\r\n    //  The words mustn't contain any spaces or numbers.\r\n\r\n    //  The shorter the array, the larger the letter tiles will scale in-game.\r\n\r\n    var _this = this;\r\n    this.words = [];\r\n    this.wordsBase = definedWords;\r\n\r\n    //this.wordsBase = ['Colaboração', 'Proximidade'];\r\n\r\n    $.each(this.wordsBase, function (index, value) {\r\n      _this.words.push(_this.removerAcentos(value).toLowerCase());\r\n    });\r\n\r\n    this.letters = [\r\n      \"A\",\r\n      \"B\",\r\n      \"C\",\r\n      \"D\",\r\n      \"E\",\r\n      \"F\",\r\n      \"G\",\r\n      \"H\",\r\n      \"I\",\r\n      \"J\",\r\n      \"K\",\r\n      \"L\",\r\n      \"M\",\r\n      \"N\",\r\n      \"O\",\r\n      \"P\",\r\n      \"Q\",\r\n      \"R\",\r\n      \"S\",\r\n      \"T\",\r\n      \"U\",\r\n      \"V\",\r\n      \"W\",\r\n      \"X\",\r\n      \"Y\",\r\n      \"Z\",\r\n      \"Ç\",\r\n      \"Ã\",\r\n      \"É\",\r\n      \"Ó\",\r\n    ];\r\n\r\n    this.puzzle = null;\r\n    this.solution = null;\r\n\r\n    //  The BitmapFont word list down the side\r\n    this.wordList = {};\r\n\r\n    //  The dimensions of the word search, in letters (not pixels)\r\n    //  You can set a fixed size here.\r\n    //  Or set to -1 means it'll adapt to fit the longest word in the words array.\r\n    this.puzzleWidth = -1;\r\n    this.puzzleHeight = -1;\r\n\r\n    //  The size of each letter sprite sheet, in pixels\r\n    this.tileWidth = 100;\r\n    this.tileHeight = 100;\r\n\r\n    //  The selection line color and thickness\r\n    this.drawLineColor = 0x00ff00;\r\n    this.drawLineAlpha = 0.6;\r\n    this.drawLineThickness = 26;\r\n\r\n    //  A tint applied to the letters when a word is found\r\n    // this.highlightTintContainer = [\"#E90F6A\", \"#0bb7e1\", \"#D9F339\"];\r\n    this.highlightTintContainer = [\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n      \"#D9F339\",\r\n    ];\r\n    this.highlightTintIndice = 0;\r\n    this.highlightTint = 0xffff00;\r\n\r\n    //  Booleans to control the game during play\r\n    this.drawLine = null;\r\n\r\n    this.isSelecting = false;\r\n    this.firstLetter = null;\r\n    this.endLetter = null;\r\n    this.foundWords = [];\r\n  };\r\n\r\n  WordSearch.Game.prototype = {\r\n    preload: function () {\r\n      //this.load.script('wordfind', 'libs/wordfind.js');\r\n\r\n      this.load.path = \"../../assets/img/game3/\";\r\n\r\n      this.load.bitmapFont(\"azo\");\r\n\r\n      var _this = this;\r\n\r\n      this.letters.forEach(function (letter) {\r\n        var nameIMG = letter;\r\n\r\n        if (letter == \"Ã\") nameIMG = \"A1\";\r\n        else if (letter == \"Ç\") nameIMG = \"C1\";\r\n        else if (letter == \"É\") nameIMG = \"E1\";\r\n        else if (letter == \"Ó\") nameIMG = \"O1\";\r\n\r\n        _this.load.spritesheet(\r\n          letter.toLowerCase(),\r\n          nameIMG + \".png\",\r\n          _this.tileWidth,\r\n          _this.tileHeight\r\n        );\r\n      });\r\n\r\n      this.scaleRatio = window.devicePixelRatio / 3;\r\n\r\n      _this.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\r\n      _this.scale.setShowAll();\r\n\r\n      window.addEventListener(\"resize\", function () {\r\n        _this.scale.refresh();\r\n      });\r\n      _this.scale.refresh();\r\n    },\r\n\r\n    create: function () {\r\n      this.stage.backgroundColor = \"#ffffff\";\r\n\r\n      activeTime();\r\n\r\n      if (this.puzzleWidth !== -1) {\r\n        this.puzzle = wordfind.newPuzzle(this.words, {\r\n          width: this.puzzleWidth,\r\n          height: this.puzzleHeight,\r\n        });\r\n      } else {\r\n        this.puzzle = wordfind.newPuzzle(this.words);\r\n        this.puzzleWidth = this.puzzle[0].length;\r\n        this.puzzleHeight = this.puzzle.length;\r\n      }\r\n\r\n      var solution = wordfind.solve(this.puzzle, this.words);\r\n\r\n      this.solution = solution.found;\r\n\r\n      //  Un-comment these to Debug the puzzle, the first outputs the puzzle to the console\r\n      //  The second outputs the answers object\r\n\r\n      // wordfind.print(this.puzzle);\r\n      // console.log(this.solution);\r\n\r\n      //  Create the letter tile grid\r\n\r\n      var x = 0;\r\n      var y = 0;\r\n      var _this = this;\r\n\r\n      this.grid = this.add.group();\r\n      this.grid.inputEnableChildren = true;\r\n\r\n      this.puzzle.forEach(function (row) {\r\n        row.forEach(function (letter) {\r\n          var tile = _this.grid.create(x, y, letter, 0);\r\n\r\n          tile.data.row = x / _this.tileWidth;\r\n          tile.data.column = y / _this.tileHeight;\r\n          tile.data.words = {};\r\n          tile.data.letter = letter;\r\n          tile.data.startWord = false;\r\n\r\n          tile.events.onInputDown.add(_this.startLetterSelect, _this);\r\n          tile.events.onInputUp.add(_this.stopLetterSelect, _this);\r\n          tile.events.onInputOver.add(_this.overLetter, _this);\r\n          tile.events.onInputOut.add(_this.outLetter, _this);\r\n\r\n          x += _this.tileWidth;\r\n        });\r\n\r\n        x = 0;\r\n        y += _this.tileHeight;\r\n      });\r\n\r\n      //  Flag all of the starting letters in the grid\r\n      this.solution.forEach(function (entry) {\r\n        //  Based on the grid position we can get the tile index\r\n        var index = entry.y * _this.puzzleWidth + entry.x;\r\n\r\n        var tile = _this.grid.getChildAt(index);\r\n\r\n        tile.data.startWord = true;\r\n        tile.data.words[entry.word] = {\r\n          orientation: entry.orientation,\r\n          length: entry.word.length,\r\n        };\r\n      });\r\n\r\n      //  This controls the position and scale of the word search grid\r\n      //  Setting the width / height automatically scales the Group\r\n      //  If you remove this, the tiles will be displayed at their full size\r\n      //\r\n      //  Use it to position the grid within your game, and make sure it fits\r\n      //  no matter how many words are in it.\r\n\r\n      this.grid.x = 45;\r\n      this.grid.y = 45;\r\n      this.grid.width = 827;\r\n      this.grid.height = 816;\r\n\r\n      //  Display the words to find down the right-hand side, and add to the wordList object\r\n\r\n      var x_InitSolution = 40;\r\n      var y_InitSolution = 880;\r\n      var x_SecondCol = 400;\r\n\r\n      x = x_InitSolution;\r\n      y = y_InitSolution;\r\n\r\n      // Palavras dicas\r\n      // this.solution.forEach(function (entry, indice) {\r\n      //   //  One BitmapText per word (so we can change their color when found)\r\n      //   var style = {\r\n      //     font: \"30px Arial\", ///Import: Usar sempre Arial para nao quebrar a font\r\n      //     fill: \"0x000000\",\r\n      //     align: \"left\",\r\n      //   };\r\n\r\n      //   x = indice < 5 ? x : x_SecondCol; /// Da quinta palavra já cria a segunda coluna\r\n      //   y = indice == 5 ? y_InitSolution : y;\r\n\r\n      //   var _palavras = _this.add.text(x, y, _this.wordsBase[indice], style);\r\n      //   _palavras.fontWeight = \"bold\";\r\n\r\n      //   _this.wordList[entry.word] = _palavras;\r\n\r\n      //   y += 42;\r\n      // });\r\n\r\n      // Verifique se a lista de palavras existe no DOM\r\n      const listContainer = document.querySelector(\"ul.listPalavras\");\r\n\r\n      // Se a lista de palavras existir no DOM\r\n      if (listContainer) {\r\n        // Iterar sobre cada entrada na solução\r\n        this.solution.forEach((entry, indice) => {\r\n          // Criar um elemento <li> para representar a palavra\r\n          const li = document.createElement(\"li\");\r\n          li.textContent = this.wordsBase[indice];\r\n\r\n          // Adicionar o elemento <li> à lista de palavras\r\n          listContainer.appendChild(li);\r\n\r\n          // Armazenar uma referência ao elemento de texto criado para a palavra correspondente\r\n          this.wordList[entry.word] = li;\r\n\r\n          // Adicionar uma classe CSS para estilizar a palavra\r\n          li.classList.add(\"word\");\r\n\r\n          // Adicionar um evento de clique para marcar a palavra como visitada\r\n          li.addEventListener(\"click\", () => {\r\n            // Marcar a palavra como visitada adicionando uma classe CSS\r\n            li.classList.add(\"visited\");\r\n          });\r\n        });\r\n      } else {\r\n        // Se a lista de palavras não existir no DOM, exibir um erro no console\r\n        console.error(\r\n          \"A lista de palavras (ul.listPalavras) não foi encontrada no DOM.\"\r\n        );\r\n      }\r\n\r\n      //  The Graphics object that controls the letter selection line\r\n\r\n      this.drawLine = this.add.graphics(0, 0);\r\n\r\n      //  This starts a callback going, that updates whenever the mouse moves,\r\n      //  and calls updateDrawLine. All of the main game logic happens as a result\r\n      //  of events triggered within here, and the letter tile input handlers.\r\n\r\n      this.input.addMoveCallback(this.updateDrawLine, this);\r\n    },\r\n\r\n    /**\r\n     * Draws the selection line, showing which letter tiles are being selected.\r\n     */\r\n    updateDrawLine: function (pointer, x, y) {\r\n      if (!this.isSelecting) {\r\n        return;\r\n      }\r\n\r\n      this.drawLine.clear();\r\n\r\n      this.drawLine.lineStyle(\r\n        this.drawLineThickness,\r\n        this.drawLineColor,\r\n        this.drawLineAlpha\r\n      );\r\n\r\n      var tw = (this.tileWidth * this.firstLetter.worldScale.x) / 2;\r\n      var th = (this.tileHeight * this.firstLetter.worldScale.y) / 2;\r\n\r\n      this.drawLine.moveTo(\r\n        this.firstLetter.worldPosition.x + tw,\r\n        this.firstLetter.worldPosition.y + th\r\n      );\r\n\r\n      this.drawLine.lineTo(x, y);\r\n    },\r\n\r\n    /**\r\n     * Called when the mouse is pressed down on any of the letter tiles.\r\n     */\r\n    startLetterSelect: function (letter) {\r\n      this.isSelecting = true;\r\n\r\n      this.firstLetter = letter;\r\n    },\r\n\r\n    /**\r\n     * Called when the mouse is released from any of the letter tiles.\r\n     * This performs all of the core checks in terms of if they've selected\r\n     * a full word, won the game, etc.\r\n     */\r\n    stopLetterSelect: function (letter) {\r\n      this.isSelecting = false;\r\n\r\n      //  Let's check to see if they selected an actual word :)\r\n      if (\r\n        this.firstLetter &&\r\n        this.endLetter &&\r\n        this.firstLetter !== this.endLetter &&\r\n        (this.firstLetter.data.startWord || this.endLetter.data.startWord) &&\r\n        this.checkLetterAlignment(this.endLetter)\r\n      ) {\r\n        var result = this.checkSelectedLetters();\r\n\r\n        if (result) {\r\n          this.highlightCorrectWord(result);\r\n          this.foundWords.push(result.word);\r\n        }\r\n\r\n        //  Check word list, game won?\r\n        if (this.foundWords.length === this.solution.length) {\r\n          this.gameWon();\r\n        }\r\n      }\r\n\r\n      this.grid.setAll(\"frame\", 0);\r\n\r\n      this.clearLine();\r\n    },\r\n\r\n    /**\r\n     * Clears the selection line, and resets the first and last letters.\r\n     */\r\n    clearLine: function () {\r\n      this.firstLetter = false;\r\n      this.endLetter = null;\r\n\r\n      this.drawLine.clear();\r\n    },\r\n\r\n    /**\r\n     * Called from within stopLetterSelect and both tints the BitmapText word\r\n     * on the right-hand side, and also tints each tile that was matched.\r\n     *\r\n     * If you're going to use a different kind of effect, then you probably want\r\n     * to edit or skip most of this function.\r\n     */\r\n    highlightCorrectWord: function (result) {\r\n      var _this = this;\r\n\r\n      countWord(1);\r\n\r\n      //  result contains the sprites of the letters, the word, etc.\r\n      var tinta = this.highlightTintContainer[this.highlightTintIndice];\r\n      this.wordList[result.word].fill = tinta;\r\n\r\n      var element = this.wordList[result.word];\r\n\r\n      // Verifica se o elemento foi encontrado\r\n      if (element) {\r\n        // Adiciona a classe 'visited' ao elemento\r\n        element.classList.add(\"visited\");\r\n      } else {\r\n        console.error(\r\n          \"Elemento não encontrado para a palavra-chave:\",\r\n          result.word\r\n        );\r\n      }\r\n\r\n      result.letters.forEach(function (letter) {\r\n        letter.tint = tinta.replace(\"#\", \"0x\");\r\n      });\r\n\r\n      this.highlightTintIndice += 1;\r\n    },\r\n\r\n    /**\r\n     * Called by the letter tile input handler when it is moused over.\r\n     * In short, it checks if it should swap frame or not.\r\n     */\r\n    overLetter: function (letter) {\r\n      if (this.isSelecting) {\r\n        if (this.checkLetterAlignment(letter)) {\r\n          this.endLetter = letter;\r\n\r\n          //  Highlight the tiles below the line (if any)\r\n          var selection = this.getSelectedLetters();\r\n\r\n          if (selection && selection.letters.length > 0) {\r\n            this.grid.setAll(\"frame\", 0);\r\n\r\n            selection.letters.forEach(function (sprite) {\r\n              sprite.frame = 1;\r\n            });\r\n          }\r\n        }\r\n      } else {\r\n        letter.frame = 1;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Swaps the letter frame back, if not in selecting mode.\r\n     */\r\n    outLetter: function (letter) {\r\n      if (!this.isSelecting) {\r\n        letter.frame = 0;\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Called once all words have been found.\r\n     */\r\n    gameWon: function (_containerTela) {\r\n      completeWord();\r\n    },\r\n\r\n    //  From this point on, all of the functions deal with checking the letters,\r\n    //  getting selected letters, and checking for word matching. There is no\r\n    //  display related code in any of the following, it's all game logic.\r\n\r\n    checkLetterAlignment: function (letter) {\r\n      var startRow = this.firstLetter.data.row;\r\n      var startColumn = this.firstLetter.data.column;\r\n      var endRow = letter.data.row;\r\n      var endColumn = letter.data.column;\r\n\r\n      return (\r\n        startColumn === endColumn ||\r\n        startRow === endRow ||\r\n        Math.abs(endColumn - startColumn) === Math.abs(endRow - startRow)\r\n      );\r\n    },\r\n\r\n    getLetterAt: function (row, column) {\r\n      var index = column * this.puzzleWidth + row;\r\n\r\n      return this.grid.getChildAt(index);\r\n    },\r\n\r\n    getSelectedLetters: function () {\r\n      if (\r\n        !this.firstLetter ||\r\n        !this.endLetter ||\r\n        this.endLetter === this.firstLetter\r\n      ) {\r\n        return false;\r\n      }\r\n\r\n      var first = this.firstLetter.data;\r\n      var last = this.endLetter.data;\r\n      var tile;\r\n      var letters = [];\r\n      var selectedWord = \"\";\r\n      var x, y, top, bottom, left, right;\r\n\r\n      //  Let's get all the letters between the first and end letters\r\n\r\n      if (first.row === last.row) {\r\n        //  Vertical grab\r\n\r\n        top = Math.min(first.column, last.column);\r\n        bottom = Math.max(first.column, last.column);\r\n\r\n        for (y = top; y <= bottom; y++) {\r\n          tile = this.getLetterAt(first.row, y);\r\n          letters.push(tile);\r\n          selectedWord = selectedWord.concat(tile.data.letter);\r\n        }\r\n      } else if (first.column === last.column) {\r\n        //  Horizontal grab\r\n\r\n        left = Math.min(first.row, last.row);\r\n        right = Math.max(first.row, last.row);\r\n\r\n        for (x = left; x <= right; x++) {\r\n          tile = this.getLetterAt(x, first.column);\r\n          letters.push(tile);\r\n          selectedWord = selectedWord.concat(tile.data.letter);\r\n        }\r\n      } else {\r\n        top = Math.min(first.column, last.column);\r\n        bottom = Math.max(first.column, last.column);\r\n        left = Math.min(first.row, last.row);\r\n        right = Math.max(first.row, last.row);\r\n\r\n        if (first.column > last.column && first.row < last.row) {\r\n          //  Diagonal NE grab (up and from left to right)\r\n          y = bottom;\r\n\r\n          for (x = left; x <= right; x++) {\r\n            tile = this.getLetterAt(x, y);\r\n            letters.push(tile);\r\n            selectedWord = selectedWord.concat(tile.data.letter);\r\n            y--;\r\n          }\r\n        } else if (first.column < last.column && first.row < last.row) {\r\n          //  Diagonal SE grab (down and from left to right)\r\n          y = top;\r\n\r\n          for (x = left; x <= right; x++) {\r\n            tile = this.getLetterAt(x, y);\r\n            letters.push(tile);\r\n            selectedWord = selectedWord.concat(tile.data.letter);\r\n            y++;\r\n          }\r\n        } else if (first.column < last.column && first.row > last.row) {\r\n          //  Diagonal SW grab (down and from right to left)\r\n          y = top;\r\n\r\n          for (x = right; x >= left; x--) {\r\n            tile = this.getLetterAt(x, y);\r\n            letters.push(tile);\r\n            selectedWord = selectedWord.concat(tile.data.letter);\r\n            y++;\r\n          }\r\n        } else if (first.column > last.column && first.row > last.row) {\r\n          //  Diagonal NW grab (up and from right to left)\r\n          y = bottom;\r\n\r\n          for (x = right; x >= left; x--) {\r\n            tile = this.getLetterAt(x, y);\r\n            letters.push(tile);\r\n            selectedWord = selectedWord.concat(tile.data.letter);\r\n            y--;\r\n          }\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return {\r\n        word: selectedWord,\r\n        inverse: Phaser.Utils.reverseString(selectedWord),\r\n        letters: letters,\r\n      };\r\n    },\r\n\r\n    checkSelectedLetters: function () {\r\n      var selection = this.getSelectedLetters();\r\n\r\n      if (selection) {\r\n        //  It's possible that a single letter could start multiple words in different directions:\r\n        //\r\n        //  cow..\r\n        //  a....\r\n        //  r....\r\n\r\n        var starter = this.firstLetter.data.startWord\r\n          ? this.firstLetter.data\r\n          : this.endLetter.data;\r\n\r\n        for (var word in starter.words) {\r\n          if (word === selection.word || word === selection.inverse) {\r\n            return {\r\n              word: word,\r\n              letters: selection.letters,\r\n            };\r\n          }\r\n        }\r\n      }\r\n\r\n      return false;\r\n    },\r\n\r\n    removerAcentos: function (s) {\r\n      var map = {\r\n        â: \"a\",\r\n        Â: \"A\",\r\n        à: \"a\",\r\n        À: \"A\",\r\n        á: \"a\",\r\n        Á: \"A\",\r\n        /*\"ã\": \"a\",\r\n        \"Ã\": \"A\",*/\r\n        ê: \"e\",\r\n        Ê: \"E\",\r\n        è: \"e\",\r\n        È: \"E\",\r\n        // é: \"e\",\r\n        // É: \"E\",\r\n        î: \"i\",\r\n        Î: \"I\",\r\n        ì: \"i\",\r\n        Ì: \"I\",\r\n        í: \"i\",\r\n        Í: \"I\",\r\n        õ: \"o\",\r\n        Õ: \"O\",\r\n        ô: \"o\",\r\n        Ô: \"O\",\r\n        ò: \"o\",\r\n        // Ò: \"O\",\r\n        // ó: \"o\",\r\n        Ó: \"O\",\r\n        ü: \"u\",\r\n        Ü: \"U\",\r\n        û: \"u\",\r\n        Û: \"U\",\r\n        ú: \"u\",\r\n        Ú: \"U\",\r\n        ù: \"u\",\r\n        Ù: \"U\",\r\n        /*\"ç\": \"c\",\r\n        \"Ç\": \"C\"*/\r\n      };\r\n\r\n      return s.replace(/[\\W\\[\\] ]/g, function (a) {\r\n        return map[a] || a;\r\n      });\r\n    },\r\n  };\r\n\r\n  //  Creates the game instance and starts it running\r\n\r\n  var game = new Phaser.Game(\r\n    measures.canvasW,\r\n    measures.canvasH,\r\n    Phaser.CANVAS,\r\n    \"game\"\r\n  );\r\n  game.state.add(\"WordSearch.Game\", WordSearch.Game, true);\r\n}\r\n"]}